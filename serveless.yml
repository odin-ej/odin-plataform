service: odin-app-prod # Nome do seu serviço Serverless (ex: odin-app-prod)

provider:
  name: aws
  runtime: nodejs18.x # Certifique-se de que corresponde à versão do Node.js da sua aplicação
  region: sa-east-1 # Sua região AWS (ex: sa-east-1 para São Paulo)
  stage: production # Estágio de deploy (pode ser 'dev', 'staging', 'production')
  memory: 1024 # Memória padrão para suas Lambdas (ajuste conforme necessário)
  timeout: 30 # Tempo limite padrão para suas Lambdas em segundos (ajuste conforme necessário)
  architecture: arm64 # Opcional: use Graviton para melhor custo/performance
  # Variáveis de ambiente que serão passadas para TODAS as suas Lambdas
  environment:
    # DATABASE_URL será lida pelo Prisma.
    # Para produção, é ALTAMENTE recomendado usar AWS Secrets Manager.
    # Se não usar Secrets Manager, insira a URL completa aqui ou em um arquivo .env
    DATABASE_URL: ${env:DATABASE_URL} # Pega de uma variável de ambiente local (ex: no seu terminal)
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: 1 # Boa prática para reutilizar conexões no Node.js Lambda
    
    # Variáveis relacionadas ao S3
    AWS_S3_BUCKET_NAME: ${env:AWS_S3_BUCKET_NAME} # odin-platform-user-avatars
    AWS_S3_CHAT_BUCKET_NAME: ${env:AWS_S3_CHAT_BUCKET_NAME} # odin-platform-knowledge-base

    # Variáveis relacionadas ao Cognito
    AWS_COGNITO_USER_POOL_ID: ${env:AWS_COGNITO_USER_POOL_ID} # sa-east-1_7Gh3XVoL7
    AWS_COGNITO_USER_POOL_CLIENT_ID: ${env:AWS_COGNITO_USER_POOL_CLIENT_ID} # 2ng6qgfmfio83f1a4s07td2vkp

    # Variável para o SES
    VERIFIED_EMAIL_FROM: ${env:VERIFIED_EMAIL_FROM} # plataforma@empresajr.org

    # Variáveis do Monday.com
    MONDAY_API_KEY: ${env:MONDAY_API_KEY}
    ALFA_BOARD: ${env:ALFA_BOARD}
    BETA_BOARD: ${env:BETA_BOARD}
    DELTA_BOARD: ${env:DELTA_BOARD}

    # Variáveis do Gemini/Google Search
    GEMINI_API_KEY: ${env:GEMINI_API_KEY}
    GOOGLE_SEARCH_API_KEY: ${env:GOOGLE_SEARCH_API_KEY}
    GOOGLE_SEARCH_ENGINE_ID: ${env:GOOGLE_SEARCH_ENGINE_ID}

    # AWS Region (para SDKs internos da Lambda)
    AWS_REGION: ${aws:region} # Pega a região do provedor (sa-east-1)

  # Configuração da VPC para suas Lambdas (CRÍTICO para acesso ao RDS)
  vpc:
    securityGroupIds:
      - sg-0228a7934137562b2 # ID do seu Grupo de Segurança da Lambda (ex: lambda-access-rds-sg)
    subnetIds:
      - subnet-0f5ae3eec18af4eef # ID da sua sub-rede privada 1 (onde o RDS está acessível)
      - subnet-04592dbcc1ba4f11e # ID da sua sub-rede privada 2 (onde o RDS está acessível)
       # Certifique-se de que essas sub-redes são PRIVADAS e têm acesso ao RDS.
      # Se suas Lambdas precisarem de acesso à internet (para APIs externas, etc.),
      # essas sub-redes privadas precisarão de um NAT Gateway em uma sub-rede pública.

  # Permissões IAM para as Funções Lambda
  iam:
    role:
      statements:
        # Permissões para CloudWatch Logs (essencial)
        - Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource: "arn:aws:logs:${aws:region}:${aws:accountId}:log-group:/aws/lambda/*:*" # Permite logs para todas as Lambdas
        # Permissões para acesso à VPC (essencial se a Lambda estiver na VPC)
        - Effect: Allow
          Action:
            - ec2:CreateNetworkInterface
            - ec2:DeleteNetworkInterface
            - ec2:DescribeNetworkInterfaces
          Resource: "*"
        # Permissões para SES (se suas Lambdas enviarem e-mails)
        - Effect: Allow
          Action:
            - ses:SendEmail
            - ses:SendRawEmail
          Resource: "*" # Ou o ARN específico da sua identidade verificada do SES
       -  Effect: Allow
          Action:
            - s3:GetObject
            - s3:PutObject
            - s3:DeleteObject
            - s3:ListBucket
          Resource:
            - "arn:aws:s3:::${env:AWS_S3_BUCKET_NAME}"
            - "arn:aws:s3:::${env:AWS_S3_BUCKET_NAME}/*"
            - "arn:aws:s3:::${env:AWS_S3_CHAT_BUCKET_NAME}"
            - "arn:aws:s3:::${env:AWS_S3_CHAT_BUCKET_NAME}/*

plugins:
  - serverless-nextjs-plugin # Habilita o plugin Next.js

custom:
  # Configurações específicas para o plugin serverless-nextjs-plugin
  # O plugin detecta automaticamente as páginas e as rotas API (route.ts)
  # e as empacota como Lambdas.
  serverless-nextjs:
    # Optional: path to your Next.js app folder (default is current directory)
    # appDir: './'
    # Optional: specify a custom build command for Next.js (default is 'next build')
    # buildCommand: 'npm run build'
    # Optional: specify a custom output directory for the Next.js build (default is '.next')
    # outputDir: '.next'
    # Opcional: Se você estiver usando o App Router, pode ser útil definir isso explicitamente
    # Embora o plugin geralmente detecte automaticamente.
    # nextjs:
    #   basePath: /
    #   appDir: true # Indica que você está usando o App Router
    # Opcional: Configurações para o deploy do Prisma
    # O plugin pode ajudar a otimizar o empacotamento do Prisma
    # Consulte a documentação do plugin para as últimas recomendações sobre Prisma.
    # Geralmente, ele lida com isso automaticamente ou você pode precisar de um Lambda Layer.
    # lambdaLayers:
    #   prisma:
    #     path: ./node_modules/.prisma/client # Exemplo para Lambda Layer
    #     compatibleRuntimes:
    #       - nodejs18.x

# Você pode definir funções Lambda adicionais aqui que não são parte do Next.js
# Por exemplo, suas funções agendadas (cron jobs)
functions:
  # Exemplo de uma função Lambda para o cron job de tarefas atrasadas
  updateOverdueTasks:
    handler: lambda-handlers/updateOverdueTasks.handler # Caminho para o seu arquivo compilado e função handler
    # A função handler deve ser o arquivo JS compilado, não o TS.
    # O plugin serverless-nextjs-plugin não gerencia funções que não são do Next.js.
    # Você precisará compilar e empacotar 'lambda-handlers/updateOverdueTasks.ts' separadamente
    # e garantir que ele esteja no seu pacote de deploy.
    # Ou, para simplificar, você pode usar um plugin como 'serverless-webpack' ou 'serverless-plugin-typescript'
    # para gerenciar a compilação e empacotamento dessas Lambdas avulsas.
    events:
      - schedule:
          rate: cron(0 3 * * ? *) # Exemplo: 03:00 AM UTC todos os dias
          enabled: true
          input: {} # Payload vazio para a Lambda
    # Esta função usará as variáveis de ambiente e a VPC definida no provedor acima,
    # a menos que você as sobrescreva aqui.
    # vpc: # Se quiser sobrescrever a VPC para esta função específica
    #   securityGroupIds:
    #     - sg-xxxxxxxxxxxxx
    #   subnetIds:
    #     - subnet-xxxxxxxxxxxxx
  resetUserMessageLimits: # Novo nome da função Lambda
    handler: lambda-handlers/resetUserMessageLimits.handler # Caminho para o seu arquivo compilado e função handler
    events:
      - schedule:
          rate: cron(0 0 * * ? *) # Exemplo: 00:00 AM UTC (meia-noite)
          enabled: true
          input: {} # Payload vazio
    # Esta função também usará as variáveis de ambiente e a VPC definida no provedor acima,
    # a menos que você as sobrescreva aqui.
  cleanupConversations: # Novo nome da função Lambda
    handler: lambda-handlers/cleanupConversations.handler # Caminho para o seu arquivo compilado e função handler
    events:
      - schedule:
          rate: cron(0 3 * * ? *) # Exemplo: 02:00 AM UTC todos os dias
          enabled: true
          input: {}